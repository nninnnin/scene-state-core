{"version":3,"sources":["../src/components/SceneStateProvider.tsx","../src/hooks/useStore.tsx","../src/hooks/useSceneState.tsx","../src/hooks/useCommand.tsx","../src/index.ts"],"names":["createContext","useRef","Store","useContext","useState","useEffect","group"],"mappings":";;;;;;;AAeO,IAAM,YAAA,GACXA,oBAA+B,IAAI,CAAA;AAE9B,IAAM,qBAAqB,CAAC;AAAA,EACjC,YAAA;AAAA,EACA,aAAA;AAAA,EACA;AACF,CAAA,KAAqB;AACnB,EAAA,MAAM,QAAA,GAAWC,aAAqB,IAAI,CAAA;AAE1C,EAAA,IAAI,aAAA,EAAe;AACjB,IAAA,QAAA,CAAS,OAAA,GAAU,aAAA;AAAA,EACrB,CAAA,MAAA,IAAW,CAAC,QAAA,CAAS,OAAA,EAAS;AAE5B,IAAA,QAAA,CAAS,OAAA,GAAU,IAAIC,UAAA,CAAM,YAAY,CAAA;AAAA,EAC3C;AAEA,EAAA,sCACG,YAAA,CAAa,QAAA,EAAb,EAAsB,KAAA,EAAO,UAC3B,QAAA,EACH,CAAA;AAEJ;AClCA,IAAM,WAAW,MAAM;AACrB,EAAA,MAAM,QAAA,GAAWC,iBAAW,YAAY,CAAA;AAExC,EAAA,IAAI,CAAC,UAAU,OAAA,EAAS;AACtB,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KAEF;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,OAAO,QAAA,CAAS;AAAA,GAClB;AACF,CAAA;AAEA,IAAO,gBAAA,GAAQ,QAAA;;;ACZf,IAAM,gBAAA,GAAmB,CACvB,KAAA,KACG,KAAA;AAEL,IAAM,0BAA0B,MAAA,CAAO,EAAA;AAUhC,SAAS,aAAA,CACd,UACA,MAAA,EACA;AAEA,EAAA,MAAM,SACJ,QAAA,IAAY,gBAAA;AACd,EAAA,MAAM,UAAW,MAAA,IACf,uBAAA;AAEF,EAAA,MAAM,EAAE,KAAA,EAAM,GAAI,gBAAA,EAAS;AAG3B,EAAA,MAAM,CAAC,UAAA,EAAY,aAAa,CAAA,GAC9BC,eAAqB,MAAM;AACzB,IAAA,MAAM,QAAQ,KAAA,EAAO,KAAA;AAErB,IAAA,OAAO,QAAA,GACH,QAAA,CAAS,KAAK,CAAA,GACb,KAAA;AAAA,EACP,CAAC,CAAA;AAEH,EAAA,MAAM,OAAA,GAAUH,aAAmB,UAAU,CAAA;AAE7C,EAAAI,eAAA,CAAU,MAAM;AACd,IAAA,MAAM,QAAA,GAAqB,CAAC,EAAE,IAAA,EAAK,KAAM;AACvC,MAAA,MAAM,QAAA,GAAW,OAAO,IAAI,CAAA;AAE5B,MAAA,IAAI,CAAC,OAAA,CAAQ,OAAA,CAAQ,OAAA,EAAS,QAAQ,CAAA,EAAG;AACvC,QAAA,OAAA,CAAQ,OAAA,GAAU,QAAA;AAClB,QAAA,aAAA,CAAc,QAAQ,CAAA;AAAA,MACxB;AAAA,IACF,CAAA;AAEA,IAAA,MAAM,WAAA,GAAc,KAAA,CAAM,SAAA,CAAU,QAAQ,CAAA;AAE5C,IAAA,OAAO,MAAM;AACX,MAAA,WAAA,EAAY;AAAA,IACd,CAAA;AAAA,EACF,CAAA,EAAG,CAAC,KAAA,EAAO,MAAA,EAAQ,OAAO,CAAC,CAAA;AAE3B,EAAA,OAAO,EAAE,UAAA,EAAW;AACtB;AC1DO,IAAM,aAAa,MAAM;AAC9B,EAAA,MAAM,EAAE,KAAA,EAAM,GAAI,gBAAA,EAAS;AAE3B,EAAA,MAAM,QAAA,GAAW,CAAC,OAAA,KAChB,KAAA,CAAM,SAAS,OAAO,CAAA;AAExB,EAAA,OAAO;AAAA,IACL,QAAA;AAAA,WACAC;AAAA,GACF;AACF;;;ACdO,SAAS,UAAA,GAAa;AAC3B,EAAA,OAAO,aAAA;AACT","file":"index.cjs","sourcesContent":["import {\n  createContext,\n  PropsWithChildren,\n  RefObject,\n  useRef,\n} from \"react\";\nimport { State, Store } from \"@ssc/core\";\n\ntype ProviderProps = PropsWithChildren<{\n  initialState: State;\n  injectedStore?: Store;\n}>;\n\ntype StoreRef = RefObject<Store | null>;\n\nexport const StoreContext =\n  createContext<StoreRef | null>(null);\n\nexport const SceneStateProvider = ({\n  initialState,\n  injectedStore,\n  children,\n}: ProviderProps) => {\n  const storeRef = useRef<Store | null>(null);\n\n  if (injectedStore) {\n    storeRef.current = injectedStore;\n  } else if (!storeRef.current) {\n    // Remove null race\n    storeRef.current = new Store(initialState);\n  }\n\n  return (\n    <StoreContext.Provider value={storeRef}>\n      {children}\n    </StoreContext.Provider>\n  );\n};\n","import { useContext } from \"react\";\nimport { StoreContext } from \"../components/SceneStateProvider\";\n\nconst useStore = () => {\n  const storeRef = useContext(StoreContext);\n\n  if (!storeRef?.current) {\n    throw new Error(\n      \"SceneStateProvider is not mounted and no global store available. \" +\n        \"Wrap your app with <SceneStateProvider initialState={...}> or pass an injectedStore in tests.\",\n    );\n  }\n\n  return {\n    store: storeRef.current,\n  };\n};\n\nexport default useStore;\n","import { useEffect, useRef, useState } from \"react\";\nimport { Listener, State } from \"@ssc/core\";\nimport useStore from \"./useStore\";\n\ntype EqualsFn<T> = (a: T, b: T) => boolean;\n\nconst fallbackSelector = <T extends unknown>(\n  state: State,\n) => state as unknown as T;\n\nconst fallbackEqualityChecker = Object.is;\n\n// overloads\nexport function useSceneState(): { sceneState: State };\nexport function useSceneState<T>(\n  selector: (state: State) => T,\n  equals?: EqualsFn<T>,\n): { sceneState: T };\n\n// implementation\nexport function useSceneState<ReturnType = State>(\n  selector?: (state: State) => ReturnType,\n  equals?: EqualsFn<ReturnType>,\n) {\n  // redefine optional funuctions\n  const select =\n    selector ?? fallbackSelector<ReturnType>;\n  const isEqual = (equals ??\n    fallbackEqualityChecker) as EqualsFn<ReturnType>;\n\n  const { store } = useStore();\n\n  // initialize scene state\n  const [sceneState, setSceneState] =\n    useState<ReturnType>(() => {\n      const state = store?.state;\n\n      return selector\n        ? selector(state)\n        : (state as ReturnType);\n    });\n\n  const prevRef = useRef<ReturnType>(sceneState);\n\n  useEffect(() => {\n    const listener: Listener = ({ next }) => {\n      const selected = select(next);\n\n      if (!isEqual(prevRef.current, selected)) {\n        prevRef.current = selected;\n        setSceneState(selected);\n      }\n    };\n\n    const unsubscribe = store.subscribe(listener);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [store, select, isEqual]);\n\n  return { sceneState };\n}\n","import { Command, group } from \"@ssc/core\";\n\nimport useStore from \"./useStore\";\n\nexport const useCommand = () => {\n  const { store } = useStore();\n\n  const dispatch = (command: Command) =>\n    store.dispatch(command);\n\n  return {\n    dispatch,\n    group,\n  };\n};\n","export function useExample() {\n  return \"react-0.0.0\";\n}\n\nexport { SceneStateProvider } from \"./components/SceneStateProvider\";\nexport { useSceneState } from \"./hooks/useSceneState\";\nexport { useCommand } from \"./hooks/useCommand\";\n"]}