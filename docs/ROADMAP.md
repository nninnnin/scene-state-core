- 아래는 “3D 씬 편집을 위한 상태·커맨드·트랜잭션·검증” 코어를 정말 작은 단위로 쪼갠 실습 로드맵
- 각 단계는 “무엇을 만든다 → 왜 필요한가 → 무엇을 확인한다”의 한 문단으로 설명합니다. 전제는 TypeScript, React, react-three-fiber(r3f), Vitest입니다.

# 0. 빈 상태 엔진 뼈대 만들기

프로젝트 루트에 `packages/core`를 만들고, `State` 타입만 가진 빈 라이브러리를 생성합니다. 지금은 아무 기능이 없어도 됩니다. 목적은 “상태 엔진은 UI와 분리된 독립 패키지”라는 경계를 처음부터 세우는 것입니다. `State`는 당분간 `{}`로 두고, 빌드·테스트 스캐폴딩이 동작하는지만 확인합니다.

# 1. 엔티티 ID와 최소 State

`type EntityId = string`과 `interface State { entities: Record<EntityId, { name: string }>; }`를 만듭니다. 왜냐면 3D 씬은 결국 “식별 가능한 객체들의 집합”이기 때문이고, 가장 단순한 형태로도 “ID→데이터” 맵 구조가 필요합니다. `createEmptyState(): State`와 `addEntity(s,id,name)` 함수를 만들고, Vitest로 “추가하면 개수가 1 늘어난다” 테스트를 통과시킵니다.

# 2. 불변 업데이트 원칙

각 함수가 기존 `State`를 직접 바꾸지 않고, “얕은 복사로 새로운 State를 반환”하게 만듭니다. 이는 React와 동기화할 때 변경 탐지를 간단하게 만들고, 스냅샷/롤백을 가능하게 합니다. 테스트에서 `const s2=addEntity(s1,...); expect(s1).not.toBe(s2)`처럼 참조가 다른지 확인합니다.

# 3. 기본 컴포넌트(Transform) 도입

3D에 필수인 `Transform`(position/rotation/scale)을 분리해 `components.transform: Record<EntityId, Transform>`로 둡니다. “엔티티 데이터”와 “컴포넌트 데이터”를 나누면, 나중에 머티리얼·메시 같은 속성을 독립적으로 추가·제거할 수 있습니다. `setTransform(s,id,t)`를 만들고, 없는 id에 설정하려 하면 에러를 던지게 합니다.

# 4. “불변식(invariant)” 개념 추가

상태가 반드시 만족해야 하는 규칙을 함수 배열로 둡니다. 예: “존재하지 않는 엔티티에 Transform이 있으면 안 된다.” `validateState(s)`가 모든 규칙을 검사해서 위반 시 에러를 던지게 합니다. 왜냐면 요구사항이 바뀌어도 “지켜야 할 안전선”을 코드로 고정해야 데이터 무결성이 유지됩니다. `addEntity`나 `setTransform` 끝에 `validateState`를 호출합니다.

# 5. Command 타입 도입

`type Command = { apply(s: State): State; invert(s: State): Command }`를 정의합니다. 상태 변경은 이제 직접 호출이 아니라 “커맨드”로만 일어나게 합니다. 이유는 되돌리기(Undo)와 트랜잭션(묶음 적용)을 위해서입니다. 예시로 `AddEntityCmd`, `SetTransformCmd` 클래스를 만들고, `apply`가 새로운 상태를 반환하도록 합니다.

# 6. 커맨드 역연산 보장 테스트

각 커맨드에 대해 `apply` 후 `invert`를 다시 `apply`하면 원래 상태가 되어야 합니다. Vitest 테스트로 `const after=cmd.apply(s); const s0=cmd.invert(after).apply(after); expect(s0).toEqual(s)`를 통과시킵니다. 이 테스트는 시간이 지나 기능이 늘어도 “되돌리기 안전”을 계속 보장합니다.

# 7. 트랜잭션(원자적 배치) 구현

`type Transaction = { id: string; commands: Command[] }`와 `applyTransaction(s, tx)`를 만듭니다. 중간에 하나라도 검증 실패 시 전체를 롤백하도록 `try…catch`로 감싸고 실패하면 기존 상태를 그대로 반환하거나 에러를 던집니다. 이유는 “여러 변경을 한 덩어리로 취급”해야 장면 편집의 일관성이 깨지지 않기 때문입니다.

# 8. 스냅샷과 롤백

`type Snapshot = Readonly<State>`로 두고 `snapshot(s): Snapshot`, `rollback(_: Snapshot): State`를 구현합니다. 내부적으로는 깊은 복사를 사용하되, 큰 씬에서도 과한 비용이 들지 않도록 구조적 공유(얕은 복사 + 변경분만 교체)를 유지합니다. 테스트로 “스냅샷 찍고 변경 후 롤백하면 스냅샷과 동일”을 검증합니다.

# 9. 이력(Undo/Redo) 스택

`History`를 만들어 `done: Command[]`, `undone: Command[]` 두 스택으로 관리합니다. `execute(cmd)`는 `apply` 후 `done`에 push, `undo()`는 `invert`를 적용하고 `undone`에 push, `redo()`는 `undone`에서 꺼내 다시 `apply`합니다. 이 작은 구조로도 대부분의 편집기 동작을 구현할 수 있습니다.

# 10. 마이그레이션(버전) 필드 추가

`State` 최상위에 `version: number`를 추가하고, `migrations: Record<number, (s: State)=>State>`를 등록합니다. 저장된 스냅샷을 불러올 때 현재 버전과 다르면, 중간 버전을 차례로 올리며 변환합니다. 이렇게 해두면 “필드가 추가/분리/이름 변경”되어도 예전 데이터가 깨지지 않습니다. 테스트로 1→2→3 연속 마이그레이션을 검증합니다.

# 11. 참조 무결성 검사 강화

메시·머티리얼 같은 컴포넌트 맵을 추가하고, 모든 맵의 키가 `entities`에 존재해야 한다는 규칙을 `validateState`에 더합니다. 또한 “삭제된 엔티티를 참조하는 컴포넌트가 없어야 한다” 같은 규칙도 추가합니다. 이렇게 규칙을 늘릴수록 요구 변경에 안전해집니다.

# 12. 선택자(Selector)와 변경 집합

`diff(prev, next): Set<EntityId>`로 어떤 엔티티가 바뀌었는지 뽑아내거나, 각 커맨드가 “영향받은 엔티티 ID”를 반환하게 합니다. UI는 이 ID 집합만 구독해 필요한 부분만 리렌더합니다. 이유는 3D에서 전체 리렌더는 비싸기 때문입니다. 테스트로 큰 상태에서 일부만 바뀌었을 때 선택자 결과가 최소 범위인지 확인합니다.

# 13. React 바인딩: 읽기 전용 어댑터

`useSceneState(selector)` 같은 읽기 전용 훅을 만들고, 내부에서는 코어 패키지의 `subscribe`를 사용합니다. 이 훅은 변경 집합을 받아서 선택자가 관심 있는 엔티티가 바뀌었을 때만 컴포넌트를 업데이트합니다. UI와 코어의 결합도를 낮추고, 나중에 상태 엔진을 교체해도 UI는 그대로 두기 위함입니다.

# 14. React 바인딩: 커맨드 디스패치 훅

`useCommand()` 훅에서 `dispatch(cmd|tx)`를 노출합니다. 컴포넌트는 상태를 직접 고치지 않고 “커맨드만 보낸다”는 원칙을 지킵니다. 이렇게 하면 테스트·되돌리기·협업 병합이 모두 쉬워집니다. 간단한 버튼으로 엔티티 추가/이동을 연결해 동작을 눈으로 확인합니다.

# 15. r3f 렌더러 최소 구현

r3f 캔버스에 `state.entities`를 순회해 `<mesh>`를 렌더링하고, `Transform`을 적용합니다. 키는 `EntityId`를 사용해서 재조립을 줄이고, 변경 집합 기반으로 필요한 메시에만 `useMemo`/`useGraph` 등의 최적화를 적용합니다. “상태가 바뀌면 해당 엔티티만 업데이트된다”는 것을 확인합니다.

# 16. 커맨드 합성(Compose)과 병합(Coalesce)

연속 드래그로 100번의 `SetTransform`이 들어오면 이력에 100개가 쌓이면 불편합니다. 같은 엔티티에 대한 연속 `SetTransform`은 하나로 병합하는 규칙을 추가합니다. 구현은 간단히 “이전 커맨드가 같은 타입·같은 대상이면 덮어쓰기”로 시작합니다. 이렇게 UX와 성능을 동시에 확보합니다.

# 17. 트랜잭션 경계와 실패 주입

트랜잭션 안에서 중간 커맨드가 실패하는 가짜 커맨드를 만들어 실패를 주입하고, 전체가 원자적으로 롤백되는지 테스트합니다. 이것이 “데이터 무결성 + 트랜잭션”의 핵심 감각을 익히는 가장 빠른 방법입니다. 실패 후에도 `validateState`가 통과하는지 함께 확인합니다.

# 18. 속성 기반 테스트(빠른 품질 확보)

`fast-check`를 도입해 무작위 엔티티 추가/이동/삭제 시퀀스를 생성하고, “항상 불변식이 유지된다”와 “스냅샷 저장 후 커맨드를 리플레이하면 동일 상태가 된다” 속성을 검증합니다. 사람 손으로 만들기 어려운 경계 케이스를 자동으로 찾을 수 있습니다.

# 19. 저장·불러오기와 버전 호환

`serialize(state): string`, `deserialize(json): State`를 만들고, `deserialize` 안에서 마이그레이션을 자동 적용합니다. 옛날 저장본을 불러와도 최신 규칙으로 동작해야 합니다. 테스트로 “구버전 JSON → 현재 State → validateState OK”를 확인합니다.

# 20. 간단 협업: 로컬 로그와 충돌 감지

서버 없이 먼저 “두 클라이언트가 각자 커맨드 로그를 만들고, 나중에 합친다”를 시뮬레이션합니다. 같은 엔티티를 동시에 다른 위치로 옮겼다면 충돌로 분류하고, 가장 마지막 타임스탬프 우선 같은 단순 정책으로 결정을 내립니다. 목적은 “동시 변경이 실제로 어떻게 꼬이는지” 체감하는 것입니다.

# 21. 협업 개선: 명시적 의도 락과 힌트

드래그 시작 시 “이 엔티티를 편집 중”이라는 의도 플래그를 상태에 기록해, 다른 클라이언트가 같은 대상을 편집하려 할 때 UI에 경고를 띄우게 합니다. 완벽한 CRDT 전에도 “충돌을 줄이는 UX 장치”가 큰 효과를 냅니다. 이 단계에서는 정책과 UI 신호만으로도 충분합니다.

# 22. 상태 사이즈와 성능 측정 포인트

천 개 엔티티에서 `apply(SetTransform)` 평균 시간, 히스토리 스택 메모리 사용량, 선택자 갱신 빈도, r3f 프레임 드롭 여부를 측정하는 작은 벤치 코드를 만듭니다. 숫자를 찍어두면 다음 최적화가 “감”이 아니라 “근거”를 가집니다.

# 23. 패키지 공개 API 고정

코어 패키지에서 외부로 내보낼 타입/함수만 `index.ts`에서 한정하고, 나머지는 내부로 숨깁니다. 문서 주석(TSDoc)과 최소 예제를 작성해 “엔진 사용자(앱)는 어떤 표면만 보면 되는가”를 분명히 합니다. API가 적을수록 변화에 강합니다.

# 24. 모노레포와 릴리즈 시뮬레이션

pnpm/changesets로 버전 상승과 배포를 흉내만 내도 좋습니다. 사소해 보이지만, “코어 변화가 앱에 안전하게 전달되는지” 체인을 조기에 확인하게 해줍니다. 프리릴리즈 태그를 써서 앱이 베타 버전을 소비하는 흐름까지 만들어봅니다.

# 25. 회귀 방지: 고정 시나리오 테스트

“엔티티 10개 생성 → 3,5번을 그룹으로 이동 → 그룹 해제 → 5번 삭제 → 저장/재불러오기 → Undo 3회” 같은 고정 시나리오를 하나 만들어 스냅샷 비교로 통째로 검증합니다. 기능이 늘어도 이 시나리오가 깨지면 바로 알려줍니다.

# 26. 실패 내성: 손상 데이터 복구 경로

의도적으로 손상된 JSON(없는 엔티티를 참조하는 Transform 등)을 `deserialize`에 넣었을 때, 안전하게 “오류 보고 + 손상 부분 제거 + 나머지 로드”가 되게 합니다. 편집기는 종종 외부/구버전 데이터를 받으므로 “부드럽게 실패”하는 경로가 중요합니다.

# 27. UI 연결 최적화 점검

React에서 `useSceneState`가 불필요하게 자주 렌더를 유발하지 않는지 `why-did-you-render`류 도구나 간단한 로깅으로 확인합니다. 커맨드 한 번에 관련된 컴포넌트만 렌더되는지, 리스트 키 안정성은 지켜지는지, r3f 오브젝트 재생성이 과도하지 않은지 체크합니다.

# 28. 커맨드 스키마 검증

`zod` 같은 런타임 스키마로 커맨드 페이로드를 검증하고, 잘못된 값(예: NaN, 무한대, 비정상 스케일)을 조기에 차단합니다. “입력단에서 막기 → 상태를 깨끗하게 유지”는 디버깅 비용을 크게 줄입니다. 테스트로 잘못된 커맨드가 거부되는지 확인합니다.

# 29. 변경 로그와 원인 추적

각 커맨드에 `meta: { by: userId; at: timestamp; reason?: string }`를 붙여, 나중에 “왜 이렇게 되었나”를 타임라인으로 출력할 수 있게 합니다. 이력 확인은 협업·버그 리포트·회귀 분석에 필수입니다. 간단한 텍스트 타임라인 UI를 만들어 눈으로 확인합니다.

# 30. 최소 데모: 상호작용 루프 완주

UI에서 “엔티티 추가 → 드래그로 이동 → Undo/Redo → 저장 → 새로고침 → 불러오기 → 계속 편집”의 한 바퀴를 끊김 없이 수행합니다. 이 루프가 매끄럽게 돌아가면, 공고의 핵심 요구(상태/커맨드/트랜잭션/검증/스냅샷/마이그레이션/상태-뷰 동기화)가 최소 구현으로 충족됩니다.

- 각 단계는 하루에 하나로 설계
- 중요한 것은 “UI 기능을 빨리 늘리는 것”이 아니라 “코어가 무결성과 되돌리기·이식성·확장성의 원칙을 지키는지”를 테스트
